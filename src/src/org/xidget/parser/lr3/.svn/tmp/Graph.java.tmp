package org.xidget.parser.lr3;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import org.xmodel.util.HashMultiMap;
import org.xmodel.util.MultiMap;

/**
 * A collection of algorithms for operating on the graph of Rules in a Grammar.
 */
public final class Graph
{
  public Graph( Grammar grammar)
  {
    this.grammar = grammar;
    computeFirst();
    computeFollow();
  }

  /**
   * Scan the symbols argument for the first symbol that produces a non-empty set of terminals.
   * Note that epsilon is never included in the terminals returned by this method since it has
   * no meaning outside of the graph algorithms.  This method may return an empty-set, which 
   * indicates that all of the input symbols are empty (or resolve to a set containing only
   * epsilon). Therefore, epsilon will never be seen in the lookahead, contrary to some 
   * implementations that I've seen.
   * @param symbols The symbols to be scanned.
   * @return Returns the set of terminals.
   */
  public Set<String> first( Collection<String> symbols)
  {
    Set<String> union = new LinkedHashSet<String>();
    for( String symbol: symbols)
    {
      if ( grammar.isTerminal( symbol)) union.add( symbol); else union.addAll( firsts.get( symbol));
      if ( !union.remove( Grammar.epsilon)) break;
    }
    return union;
  }

  /**
   * Compute the follow-sets for the grammar rules.
   */
  private void computeFollow()
  {
    MultiMap<String, Rule> map = new HashMultiMap<String, Rule>();
    for( Rule rule: grammar.rules())
    {
      for( String symbol: rule.rhs())
      {
        if ( !grammar.isTerminal( symbol))
        {
          map.put( symbol, rule);
        }
      }
    }
    
    for( String nt: grammar.lhs())
    {
      Set<String> set = computeFollow( nt, map);
      follows.put( nt, set);
    }
  }
  
  /**
   * Compute the follow-set for the specified non-terminal.
   * @param nt The non-terminal.
   * @param map A map of non-terminals to the rules in which they appear.
   * @return Returns the follow-set.
   */
  private Set<String> computeFollow( String nt, MultiMap<String, Rule> map)
  {
    Set<String> union = new LinkedHashSet<String>();
    for( Rule rule: map.get( nt))
    {
      List<String> rhs = rule.rhs();
      for( int i=1; i<rhs.size(); i++)
      {
        String prev = rhs.get( i-1);
        if ( prev.equals( nt))
        {
          String next = rhs.get( i);
          union.addAll( first( rhs.subList( i, rhs.size())));
        }
      }
    }
    return union;
  }
  
  /**
   * Compute the first-sets for the grammar rules.
   */
  private void computeFirst()
  {
    firsts = new LinkedHashMap<String, Set<String>>();
    List<Rule> rules = sort();
    for( Rule rule: rules)
    {
      Set<String> union = firsts.get( rule.name());
      if ( union == null)
      {
        union = new LinkedHashSet<String>();
        firsts.put( rule.name(), union);
      }
      
      Set<String> set = computeFirst( rule);
      union.addAll( set);
    }

<<<<<<< .mine
    System.out.println( "\nLOOKAHEAD ------------------------\n");
=======
    System.out.println( "\nFIRST ------------------------\n");
>>>>>>> .r96
    for( Rule rule: rules) 
      System.out.printf( "%s: %s\n", rule.name(), firsts.get( rule.name()));
    System.out.println();
  }
  
  /**
   * Compute the first-set for the specified rule.
   * @param rule The rule.
   * @return Returns the set.
   */
  private Set<String> computeFirst( Rule rule)
  {
    Set<String> union = new LinkedHashSet<String>();
    
    for( String symbol: rule.rhs())
    {
      if ( grammar.isTerminal( symbol))
      {
        union.add( symbol);
      }
      else
      {
        Set<String> set = firsts.get( symbol);
        if ( set != null) union.addAll( set);
      }
      
      if ( !union.remove( Grammar.epsilon)) break;
    }
    
    if ( union.size() == 0) union.add( Grammar.epsilon);
    
    return union;
  }
  
  /**
   * Sort the grammar rules in order of dependencies.
   * @return Returns the sorted list of rules.
   */
  private List<Rule> sort()
  {
    List<Rule> sourceList = new ArrayList<Rule>( grammar.rules());
    List<Rule> resultList = new ArrayList<Rule>( sourceList.size());

    Stack<Rule> stack = new Stack<Rule>();
    while ( sourceList.size() > 0)
    {
      Rule rule = sourceList.remove( 0);
      stack.push( rule);
      while ( !stack.empty())
      {
        rule = stack.peek();
        boolean found = false;
        Iterator<Rule> iter = sourceList.iterator();
        while ( iter.hasNext())
        {
          Rule candidate = iter.next();
          if ( rule.rhs().contains( candidate.name()))
          {
            found = true;
            stack.push( candidate);
            iter.remove();
            break;
          }
        }

        if ( !found)
        {
          stack.pop();
          resultList.add( rule);
        }
      }
    }

    return resultList;
  }
  
  private Grammar grammar;
  private Map<String, Set<String>> firsts;
  private Map<String, Set<String>> follows;
}
